---
title: "Introduction to git and github"
subtitle: "Fundamentals of programming using R" 
author: 
date: 
urlcolor: blue
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true # toc_float option to float the table of contents to the left of the main document content. floating table of contents will always be visible even when the document is scrolled
      #collapsed: false # collapsed (defaults to TRUE) controls whether the TOC appears with only the top-level (e.g., H2) headers. If collapsed initially, the TOC is automatically expanded inline when necessary
      #smooth_scroll: true # smooth_scroll (defaults to TRUE) controls whether page scrolls are animated when TOC items are navigated to via mouse clicks
    number_sections: true
    fig_caption: true # ? this option doesn't seem to be working for figure inserted below outside of r code chunk    
    highlight: tango # Supported styles include "default", "tango", "pygments", "kate", "monochrome", "espresso", "zenburn", and "haddock" (specify null to prevent syntax    
    theme: default # theme specifies the Bootstrap theme to use for the page. Valid themes include default, cerulean, journal, flatly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, and yeti.
    df_print: tibble #options: default, tibble, paged
    keep_md: true # may be helpful for storing on github
    
---

# Introduction


Load packages
```{r, message=FALSE}
library(tidyverse)
```

Resources used to create this lecture

- https://happygitwithr.com/
- https://edquant.github.io/edh7916/lessons/intro.html
- https://www.codecademy.com/articles/f1-u3-git-setup
- https://medium.com/@lucasmaurer/git-gud-the-working-tree-staging-area-and-local-repo-a1f0f4822018

## What and why use git and GitHub?

What is __version control__?

- [Version control](https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control) is a "system that records changes to a file or set of files over time so that you can recall specific versions later"
- keeps records of changes, who made changes when,
- you or collaborators take "snapshots" of a document at a particular point in time. Later on, you can recover any previous snapshot of a document

How version control works

- Imagine you write a simple text file document that gives a recipe for yummy chocolate chip cookies and you save it as `cookies.txt`
- Later on, you make changes to `cookies.txt` (e.g., add alternative baking time for people who like "soft and chewy" cookies)
- When using version control to make these changes, you don't save entirely new version of `cookies.txt`; rather, you save the changes made relative to the previous version of `cookies.txt`


Why use version control when you can just save new version of document?

1. Saving entirely new document each time a change is very inefficient from a memory/storage perspective. 
    - When you save a new version of a document, much of the contents are the same as the previous version
    - Inefficient to devote space to saving multiple copies of the same content.
1. When document undergoes lots of changes -- especially a document that multiple people collaborating on -- hard to keep track of so many different documents. Easy to end up with a situation like this:



[![](https://pbs.twimg.com/media/B9HgQmDIEAALfb4.jpg)](http://www.phdcomics.com/comics/archive.php?comicid=1531)

*Credit: Jorge Chan (and also, lifted this example from Benjamin Skinner's [intro to Git/GitHub lecture](https://edquant.github.io/edh7916/lessons/intro.html))*

<br>

What is __Git__? (from git [website](https://git-scm.com/))

> "Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency"

- Git is a particular version control software created by The Git Project
- Git can be used by:
    - an individual/standalone developer
    - for collaborative projects, where multiple people collaborate on each file
- The term "__distributed__" means that every user collaborating on the project has access to all files and the history of changes to all files
- Git is the industry standard version control system used to create software
- Increasingly, Git is the industry standard for collaborative academic research projects

What is a __Git repository__?

- A project managed in Git is called a `Git repository`
- From (Git Handbook)[https://guides.github.com/introduction/git-handbook/] by github.com:
    - A repository "encompasses the entire collection of files and folders associated with a project, along with each file’s revision history."
    - Because git is a __distributed__ version control system, "repositories are self-contained units and anyone who owns a copy of the repository can access the entire codebase and its history"
- This course is a Git repository    
- Local vs. remote git repository
    - __local__ git repository: git repository for a project stored on your machine
    - __remote___ git repository: git repository for a project stored on the internet
- Typically, a local git repository is connected to a remote git repository
    - You can make changes to local repository on your machine and then __push__ those changes to the remote repository
    - A collaborator can make changes to their local repository, push them to the remote repository, and then you can __pull__ these changes into your local repository


What is __GitHub__?

- GitHub is the industry standard hosting site/service for Git repositories
    - Hosting services allow people/organizations to store files on the internet and make those files available to others
- Github stores your local repositories in "the cloud"
    - e.g., if you create a local repository stored on your machine, GitHub enables you to create a "remote" version of this repository
    - also, you can connect to a remote repository that already exists and create a local version of this respository on your machine
- More broadly, GitHub enables you to store files, share code, collaborate with others


## How we will learn Git and GitHub

> "Whoah, I’ve just read this quick tutorial about git and oh my god it is cool. I feel now super comfortable using it, and I’m not afraid at all to break something.”— said no one ever ([Pierre de Wulf](https://www.daolf.com/posts/git-series-part-1/))

NOTE FOR LATER: READ HIS THREE POSTS ON UNDERSTANDING WHAT'S IN .GIT AND PUT THAT INFO IN LATER CHAPTER OF YOUR GITHUB LECTURE

- https://www.daolf.com/posts/git-series-part-1/ [part 1, what's in .git]
- https://www.daolf.com/posts/git-series-part-2/ [part 2, rebasing and "golden rule"]
- https://www.daolf.com/posts/git-series-part-3/ [part 3, more on rebase]

Understanding and learning how to use Git and GitHub can be intimidating. A lot of tutorials give you recipes for how to accomplish specific tasks (either point-and-click or issuing commands on command line), but don't provide a conceptual understanding of how things work.

Here is how we will learn Git and Github over the course of the quarter:

- The first of three "units" of the course will be (mostly) devoted to Git and GitHub
- During the Git/GitHub unit, we will:
    - Provide a conceptual overview of concepts and workflow
    - Show you how to accomplish specific tasks by issuing commands on the command-line
    - Devote time to providing in-depth conceptual understanding of particular topics/concepts
    - You will practice doing Git/GitHub stuff during in-class exercises and in weekly problem sets
- With the exception of doing a few tasks on (https://github.com/)[github.com] (e.g., "issues"), we will perform all tasks on the "command line" rather than using a point-and-click graphical user interface (GUI)
    - Initially, this will feel intimidating, but after a few weeks you will see that this helps you understang git/github better and is much more efficient
- After the Git/GitHub unit:
    - Weekly problem sets will be completed and submitted using GitHub
    - When communicating with your problem-set "team," you will use GitHub "issues"
    - When posing questions to instructors/classmates, you will use GitHub "issues"

Organization of `github_lecture.Rmd`, which will be the basis for the Git/GitHub unit

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
source("render_toc.R")
```

```{r toc, echo=FALSE}
#INSERT TOC HERE
render_toc("github_lecture.Rmd")
```

# Overview of core concepts and work flow


This section introduces some core concepts and then explains the Git "work flow" (i.e., how Git works)

## Git stores "snapshots," not "differences"

Version control systems that save "differences"

- Prior to Git, "centralized version control systems" were the industry standard version control systems (About Version Control)[https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control]
    - In these systems, a central server stored all the versions of a file and "clients" (e.g., a programmer working on a project on their local computer) could "check out" files from the central server
- These centralized version control systems stored multiple versions of a file as "differences"
    - For example, imagine you create a simple text file called `twinkle.txt`
    - "Version 1" (the "base" version) of `twinkle.txt` has the following contents:
        - `twinkle, twinkle, little star`
    - You make some changes to `twinkle.txt` and save those changes, resulting in "Version 2," which has the following contents:
        - `twinkle, twinkle, little star, how I wonder what you are!`
    - When storing "Version 2" of `twinkle.txt`, centralized version control systems don't store the entire file. Rather, they store the changes relative to the previous version. In our example, "Version 2" stores:
        - `, how I wonder what you are!`
- The below figure portrays version control systems that store data as changes relative to the base version of each file:    

<br>

[![](https://git-scm.com/book/en/v2/images/deltas.png)](https://git-scm.com/book/en/v2/Getting-Started-What-is-Git%3F)

*Credit: [Getting Started - What is Git](https://git-scm.com/book/en/v2/Getting-Started-What-is-Git%3F)*

<br>

Git stores data as "snapshots" rather than "differences" (From [Getting Started - What is Git](https://git-scm.com/book/en/v2/Getting-Started-What-is-Git%3F))

- Git doesn't think of data as differences relative to the base version of each file
- Rather, Git thinks of data as "a series of snapshots of a minature filesystem" or, said differently, a series of snapshots of all files in the repository.
- "With Git, every time you commit, or save the state of your project, Git basically takes a picture of what all your files look like at that moment and stores a reference to that snapshot."
- "To be efficient, if files have not changed, Git doesn’t store the file again, just a link to the previous identical file it has already stored."
- The below figure portrays storing data as a stream of snapshots over time:

<br>

[![](https://git-scm.com/book/en/v2/images/snapshots.png)](https://git-scm.com/book/en/v2/Getting-Started-What-is-Git%3F)

*Credit: [Getting Started - What is Git](https://git-scm.com/book/en/v2/Getting-Started-What-is-Git%3F)*

<br>

__Commits__

- A `commmit` is a snapshot of all files in the repository at a particular time
- Example: Imagine you are working on a project (repository) that contains a dozen files.
    - You change two files and make a `commit`
    - Git takes a snapshot of the full repository (all files)
    - Content that remains unchanged relative to the previous `commit` is stored vis-a-vis a link to the previous commit

## Three components of a Git project

- __Local working directory (also called "working tree")__
    - This is the area where all your work happens! You are writing Rmd files, debugging R-scripts, adding and deleting files
    - These changes are made on your local machine!
- __Git index/staging area__
    - The staging area is the area between your _local working directory_ and the _repository_ where you list changes you have made in the local working directory that you would like to commit to the repository
    - Hypothetical work flow (imagine you are working on document cookies.txt):
        - make changes to cookies.txt on a text editor. These are changes made in your _local working directory_
        - Imagine you are happy with some changes you made to cookies.txt and you want to `commit` those changes to your repository
        - Before you `commit` changes to repository, you must `add` them to the _staging area_ as an intermediary step
- __Repository__
    - This is the actual repository where Git permanently stores the changes you’ve made in the local working directory and listed in the staging area as different versions of the project file
    - Hypothetical work flow to cookies.txt
        - `add` changes from _local working directory_ to _staging area_
        - `commit` changes from _staging area_ to _repository_
    - each `commit` to the repository is a different version of the file that represents a snapshot of the file at a particular time
    - local vs. remote repository
        - when you `add` a change to the `staging area` and then `commit` the change to your repository, this changes your __local repository__ rather than your __remote repository__
        - If you want to change your __remote repository__, you must `push` the change from your __local repository__ to your __remote repository__

<br>

[![](https://miro.medium.com/max/686/1*diRLm1S5hkVoh5qeArND0Q.png)](https://medium.com/@lucasmaurer/git-gud-the-working-tree-staging-area-and-local-repo-a1f0f4822018)

*Credit: Lucas Maurer, medium.com*

## Git/GitHub work flow

<br>

[![](https://www.jrebel.com/sites/rebel/files/blog-images/2016/02/GitHub-cheat-sheet-graphic-v1.jpg)](https://www.jrebel.com/blog/git-cheat-sheet)

*Credit: Simon Maple, JRebel, https://www.jrebel.com/blog/git-cheat-sheet*


- `add`: add file from working directory to staging area
- `commit`: commit file from staging area to local repository
- `push`: send files from local repository (your machine) to remote repository
    - Synchronizes local repository and remote repository
    - Think of `push` as "uploading"
- `fetch`: get files from remote repository and put them in local repository
- `pull`: get files from remote repository and put them in the working directory
    - Think of `pull` as "downloading"
    - `pull` is effectively `fetch` followed by `merge` (discussed later)
- `reset`: after you `add` files from working directory to staging area, `reset` unstages those files

## Branch and merge

### Branches

HELPFUL RESOURCES ON BRANCHES I USED TO CREATE THIS SECTION

- https://geeks.uniplaces.com/mastering-branches-in-git-f20cb2d0c51f
- https://backlog.com/git-tutorial/using-branches/
- https://guides.github.com/activities/hello-world/

Why are __branches__ necessary? (Drawing from [Using branches](https://backlog.com/git-tutorial/using-branches/) tutorial)

- __Branching__ is a means of working on different versions of files in a repository at one time
    - Branching is useful for "solo developer" projects (e.g., a PhD dissertation that does not build on an existing project) but is essential for collaborative projects
- In collaborative projects, it is common for several programmers to share and work on the same programming scripts
- Example in programming/software development world: 
    - Imagine your bank is creating a new mobile banking app.
    - Some programmers are fixing a bug in how the app imports data from your account
    - Other programmers are developing a new feature (e.g., allowing users to use Venmo to transfer funds)
    - "With so much going on, there needs to be a system in place for managing different versions of the same code base."
- Example from social science research world:
    - In the [Unrollment Project](https://github.com/eddatasci/unrollment_proj) we are exploring potential bias in alternative algorithms to predict student success
    - We have a file [predict_grad.Rmd](https://github.com/eddatasci/unrollment_proj/blob/master/scripts/rmd/predict_grad.Rmd) that reads in secondary data, creates analysis variables, runs alternative models for predicting the probability of obtaining a BA
    - Several collaborators are working on different parts of [predict_grad.Rmd](https://github.com/eddatasci/unrollment_proj/blob/master/scripts/rmd/predict_grad.Rmd). For example, one person writing functions to clean data and create analysis variables and another person writing functions to run models and store model results.
    - Need a way for multiple people to work on [predict_grad.Rmd](https://github.com/eddatasci/unrollment_proj/blob/master/scripts/rmd/predict_grad.Rmd) at the same time.
    
What is a __branch__?

- A branch is an "independent line of development" that "isolates your work from that of other team members" ([Using branches](https://backlog.com/git-tutorial/using-branches/) tutorial)
- By default, a git repository "has one branch named __master__ which is considered to be the definitive branch. We use [other] branches to experiment and make edits before committing them to __master__" ([Hello World](https://guides.github.com/activities/hello-world/) tutorial)
- "When you create a branch off the __master__ branch, you’re making a copy, or snapshot, of master as it was at that point in time"
- Branches as sometimes described as "deviations" from the master branch
- The below image shows three branches -- the master, "Branch 1," and "Branch 2" -- and each circle represents a `commit`

[![](https://miro.medium.com/max/552/1*PiduCtSA7kMwdPiMZo1nHw.jpeg)](https://geeks.uniplaces.com/mastering-branches-in-git-f20cb2d0c51f)

*Credit: [Mastering git branches](https://geeks.uniplaces.com/mastering-branches-in-git-f20cb2d0c51f) by Henrique Mota*

<br>

Defining branches in terms of commits

- People often define a __branch__ as "a pointer to a single commit"
    - In programming, a "pointer" is a variable/object that stores the address of other variables or objects in memory
- Recall that a `commit` is a snapshot of a repository at a particular point in time
    - Each commit also stores connections (referred to as "references") between the current commit and previous commit (referred to as "ancestors")
- The figure below shows the relationship between commits, references, and branches
- Below, commits 1, 2, 3, and 4 are made to the __master__ branch, prior to the creation of "Branch 1"
    - When we make "commit 2," we create "reference 1," which is a pointer from "commit 2" to "commit 1"
- "commit 4" is the last commit made to the master branch prior to the creation of "branch 1"
- We can think of "branch 1" as a pointer to "commit 4"
- When we make additional commits to "branch 1" (e.g., "commit 5," "commit 7") we also create create references to the previous commit
    - For example, "commit 5" creates "reference 4," which is a pointer from "commit 5" to "commit 4"

<br>

[![](https://miro.medium.com/max/626/1*IkZTYrKIf8E3chEvgIiOxA.jpeg)](https://geeks.uniplaces.com/mastering-branches-in-git-f20cb2d0c51f)

*Credit: [Mastering git branches](https://geeks.uniplaces.com/mastering-branches-in-git-f20cb2d0c51f) by Henrique Mota*

### Merges

RESOURCES USED TO CREATE SUB-SECTION

- https://www.freecodecamp.org/news/an-introduction-to-git-merge-and-rebase-what-they-are-and-how-to-use-them-131b863785f/
- https://geeks.uniplaces.com/mastering-branches-in-git-f20cb2d0c51f
- https://community.intersystems.com/post/continuous-delivery-your-intersystems-solution-using-gitlab-part-i-git

The goal of a `merge` is to "integrate changes from multiple branches into one [branch]" ([An introduction to Git merge and rebase](https://www.freecodecamp.org/news/an-introduction-to-git-merge-and-rebase-what-they-are-and-how-to-use-them-131b863785f/))

The below image shows a merge between the __master__ branch a branch named "develop"

- Each circle represents a `commit`
- the "develop" branch was created after "commit 2" of the __master__
- After two commits, the "develop" branch is merged "into" the __master__

<br>
[![](https://community.intersystems.com/sites/default/files/inline/images/risunok4.png)](https://community.intersystems.com/post/continuous-delivery-your-intersystems-solution-using-gitlab-part-i-git)

*Credit: [Eduard Lebedyuk](https://community.intersystems.com/post/continuous-delivery-your-intersystems-solution-using-gitlab-part-i-git)*

<br>
Merge terminology

- "current branch"
    - branch you are currently working with
    - the branch will be updated/modified by the `merge` with the "target branch"
    - in the figure above, the __master__ branch is the "current branch"
- "target branch"
    - branch that will be merged "into" the "current branch"
    - target branch will be unaffected by the merge
    - often, programmers delete the target branch after merging with the current branch
    - in the figure above, "develop" is the target branch
    
How programmers use branches and merges in day-to-day work

- Typically, programmers do all work on branches rather than the __master__ branch
    - For example, in the [Unrollment Project](https://github.com/eddatasci/unrollment_proj), project co-founders [Will Doyle](https://github.com/wdoyle42) and [Ben Skinner](https://github.com/btskinner). stated that all project work should be done on branches rather than the master
- Branches are created for specific tasks (e.g., fixing a bug, adding a new feature)
    - GitHub.com states states "Short-lived topic branches, in particular, keep teams focused" [Git Handbook](https://guides.github.com/introduction/git-handbook/)
    - Once, the specific task is completed, the "topic" branch is merged into the __master__ branch and then the topic branch is often deleted

<br>
Later on, we will devote more time to learning the conceptual and technical aspects of merging





“Here at GitHub, our developers, writers, and designers use branches for keeping bug fixes and feature work separate from our master (production) branch. When a change is ready, they merge their non-master branch into the master branch”

Create a branch: Topic branches created from the canonical deployment branch (usually master) allow teams to contribute to many parallel efforts. Short-lived topic branches, in particular, keep teams focused and results in quick ships



Git merge 
https://guides.github.com/introduction/git-handbook/
“git merge merges lines of development together. This command is typically used to combine changes made on two distinct branches. For example, a developer would merge when they want to combine changes from a feature branch into the master branch for deployment.

## Models for collaborative development

RESOURCES USED TO CREATE SUB-SECTION

- https://guides.github.com/introduction/git-handbook/

Two primary ways people collaborate on GitHub

1. Shared repository
1. Fork and pull

### Shared repository

<br>
[![](https://miro.medium.com/max/1698/1*CEyiDu_mQ5u9NI0Fr2pSdA.png)](https://medium.com/faun/centralized-vs-distributed-version-control-systems-a135091299f0)

*Credit: [Matuesz Lubanski](https://medium.com/faun/centralized-vs-distributed-version-control-systems-a135091299f0)*

<br>


Overview of shared repository work flow

- All work on project happens on a single repository
- Everyone working on the project `clones` the repository to their local computer
- Designate level of "access" for each team member
    - read access
    - write access
    - administrator access
- As an individual team member, you work on specific tasks (e.g., fix a bug, add a new feature, write a lecture on a topic)
    - Work on tasks in your local working directory on your local machine
        - Often, work on tasks in a branch other than __master__
    - Once you complete a task, `commit` changes to your local repository
    - `push` changes from local repository on your machine to remote repository shared with collaborators
- Other team members also working on specific tasks that they `commit` to their local repository and then `push` to the remote repository
    - After your team members `push` a change to remote respository, you may `pull` those changes to your local repository and local working directory
- Issuing a "pull request"
    - For most collaborative projects, users do not simply `push` changes from their local repository to the shared remote repository
    - Why? Before pushing changes to shared repository, those changes should be reviewed by other team members
    - Instead of simply pushing changes to shared repository, a team member issues a "pull request"
    - A "pull request" is an announcement to team members that you have made changes and you want those changes to be reviewed before they become finail (i.e., pushed to shared repository)
        - "If you send a pull request to another repository, you ask their maintainers to pull your changes into theirs (you more or less ask them to use a git pull from your repository)" [Stacl Overflow](https://stackoverflow.com/questions/44669519/difference-between-git-pull-and-git-request-pull)
    - Once you issue a pull request, "the person or team reviewing your changes may have questions or comments. Perhaps the coding style doesn't match project guidelines, the change is missing unit tests, or maybe everything looks great and props are in order" [Understanding the GitHub flow](https://guides.github.com/introduction/flow/)
    - We will devote more time to understanding, doing "pull requests" later


### Fork and pull

RESOURCES

- https://guides.github.com/introduction/git-handbook/
- https://guides.github.com/activities/forking/


What is a "fork"

- A fork is a copy of a repository that is associated with an individual's personal account
- The individual has full control of their fork (read, write, administrator)

Why use forks?

- For projects with many contributors, can become overwhelming to manage the project and to manage individual permissions using the "shared repository" model

<br>
[![](https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/2016/02/14550049531.jpg)](https://www.sitepoint.com/quick-tip-synch-a-github-fork-via-the-command-line/)

*Credit: [Shaumik Daityari](https://www.sitepoint.com/quick-tip-synch-a-github-fork-via-the-command-line/)*

<br>

Overview of "fork and pull" work flow

- Create a fork repository (copy of project repository associated with your personal account) of the `central_repo` repository
    - let's call the forked repository `your_fork`
    - initially, `your_fork` repository only exists on GitHub
- `clone` the `your_fork` repository to your local machine
- On the local "working directory," make changes to files
- When you are happy with changes you have made:
    - `add` changes to index/staging area
    - `commit` changes to local `your_fork` repository 
    - `push` changes to remote `your_fork` repository
- Issue a "pull request" asking that the changes you have made to remote `your_fork` repository be incorporated to the main `central_repo` repository    

## Good habits for work flow


# Command line

## Shell/command line vs. graphical user interface (GUI)

What is a "shell"?

- "A shell is a terminal application used to interface with an operating system through written commands" [Git Bash tutorial](https://www.atlassian.com/git/tutorials/git-bash)
- "The shell is a program on your computer whose job is to run other programs. Pseudo-synonyms are 'terminal', 'command line', and 'console' [Happy Git and GitHub for the useR by Jenny Bryan](https://happygitwithr.com/shell.html)
- In this course, we will usually use the term "command line" rather than "shell"
- In the command line, you issue commands one line at a time
- Most programmers use the command line rather than a graphical user interface (GUI) to accomplish tasks

What is graphical user interface (GUI)?

- A graphical user interface an an interface for using a program that includes graphical elements such as windows, icons, and buttons that the user can click on using the mouse
- For example, "RStudio" has GUI capabilities in that it has windows and you can perform operations using point-and-click (however, RStudio also has command line capabilities)
- RStudio also includes a GUI interface for performing Git operations
- There are many other GUI software packages for performing GIT operations
    - Popular tools include "GitHub Desktop," "GitKraken," and "SmartGit"
    - see [GUI Clients](https://git-scm.com/downloads/guis)

In this course, we will perform Git operations solely using the command line. Why?

- Learning Git from the command line will give you a deeper understanding of how Git and GitHub work
    - I have found that performing GIT operations using a GUI did nothing to help me overcome my feelings of anxiety/intimidation about Git
    - As soon as I started doing stuff on the command line, I started feeling less intimidated
- After you start feeling more comfortable with the command line, using the command line makes you __much__ more efficient than using a GUI
- Learning the command line takes time and does feel intimidating
    - So we will devote substantial time in-class and during problem sets to learning/practicing the command line

Which command line program will we use to perform Git operations?

We will use the Unix shell called "Bash" to perform Git operations

- Some background on "Bash"
    - Unix is an operating system developed by AT&T Bell Labs in the late 1960s
    - The "Unix shell" is a command line program for issuing commands to "Unix-like" operating systems [Unix Shell](https://en.wikipedia.org/wiki/Unix_shell)
        - Unix-like operating systems include macOS and Linux, but not Windows
        - The first Unix shell was the "Thompson shell" originally written by Ken Thompson at Bell Labs in 1971
    - The Bourne shell was a Unix shell programming language written by Stephen Bourne at Bell Labs in 1979
    - The "Bourne Again Shell" - commonly referred to as "Bash" was "written by Brian Fox for the GNU Project as a free software replacement for the Bourne shell," and first released in 1989
- Relationship between Git and Bash
    - "At its core, Git is a set of command line utility programs that are designed to execute on a Unix style command-line environment" [GIT Bash](https://www.atlassian.com/git/tutorials/git-bash)
- Mac users
    - "Terminal" is the application that enables you to control your Mac using a command line prompt
    - Terminal runs the Bash shell programming language
    - Therefore, Mac users use "Terminal" to perform Git operations and the commands to perform Git operations utilize the Bash programming language
- Windows users
    - Windows is not a "Unix-like" operating system. Therefore, Bash is not the default command line interface
    - In order for Windows users to use Bash to perform Git operations, you must install the Git Bash program, which is installed as part of "git for Windows" ([install here](https://gitforwindows.org/))
- Because Mac "Terminal" program and the Windows "Git Bash" program both use the Bash command line program, performing Git operations using the command line will be __exactly the same__ for both Mac and Windows users!!!

### Command-line bullshittery

<br>

[Helping my students overcome __command-line bullshittery__ by Philip J. Guo](http://www.pgbovine.net/command-line-bullshittery.htm)

> "What is wonderful about doing applied computer science research in the modern era is that there are thousands of pieces of free software and other computer-based tools that researchers can leverage to create their research software. With the right set of tools, one can be 10x or even 100x more productive than peers who don't know how to set up those tools."

> "But this power comes at a great cost: __*It takes a tremendous amount of command-line bullshittery to install, set up, and configure all of this wonderful free software*__. What I mean by command-line bullshittery is dealing with all of the arcane, obscure, strange bullshit of the command-line paradigm that most of these free tools are built upon....So perhaps what is more important to a researcher than programming ability is adeptness at dealing with command-line bullshittery, since that enables one to become 10x or even 100x more productive than peers by finding, installing, configuring, customizing, and remixing the appropriate pieces of free software."

## Basic (Bash) commands line commands


### Bash syntax

Let's learn a bit about Bash command syntax

RESOURCES TO CREATE SECTION

- http://www.compciv.org/topics/bash/command-structure/
- https://www.educative.io/blog/bash-shell-command-cheat-sheet


The Bash command `ls` lists the contents (e.g., files, folders) of a directory. A "directory" is another word for "folder." In Terminal/Git Bash, try typing `ls` and then hit `ENTER` key. 

The `pwd` command shows the filepath of the directory you are currently in, that is the current working directory. In Terminal/Git Bash, try typing `pwd` and then hit `ENTER` key.

Note that you can also run `Bash` code from within an R code chunk of a .Rmd file. First, let's run some simple `R` commands from within an R code chunk

```{r}
library(tidyverse)
mpg %>% head(5)
```

We cun run `Bash` code instead of `R` code by replacing `{r}` with `{bash}` at top of chunk.

- Note that the default working directory when you run a code chunk in a .Rmd file is the directory where the .Rmd file is saved
    - This is true for an `R` code chunk, a `Bash` code chunk, or any other programming language
    - If you change working directories within a code chunk, the working directory reverts back to where the .Rmd file is saved after the code chunk finishes running
```{bash}
pwd
ls
```

We can see the help file for any Bash command by typing:

- `command_name --help`
- For example:
    `ls --help`
```{bash}
ls --help
```

Syntax of `ls` command:

- `ls [option(s)] [file(s)]`
- The bracketed `[option(s)]` and `[file(s)]` means that you do not need to specify these
- Options in the `ls` command
    - in the help file for `ls` we see that most options can be specified using `-` or `--`
    - for example, `-a` and `--all` or two different ways to specify the option "do not ignore entries starting with ."
    - for the most part, `--` is the way to specify the long name version of an option and `-` is the way to specify the short name version. For more see [blog discussion](https://askubuntu.com/questions/813303/whats-the-difference-between-one-hyphen-and-two-hyphens-in-a-command)
    
Example, using `ls` command (run in code chunk and run on command line)

- without options
```{bash}
pwd
ls
```

- using `-a` to include entries that start with `.`
```{bash}
pwd
ls -a
```

- using `--all` to include entries that start with `.`
```{bash}
pwd
ls --all
```

### Changing directories

__`cd` command changes the current directory__

- syntax
    - `cd [option(s)] directory_name`
- example: change current directory to the "lectures" directory
    - `cd lectures`
- In Bash, separate sub-folders using `/` rather than `\` [even if you are using a PC!]
- __absolute__ vs. __relative__ filepaths
    - can specify `directory_name` using __absolute__ or __relative__ filepaths
    - __absolute__ filepaths: the complete filepath relative to the "root" directory
        - example: `cd "/c/Users/ozanj/documents/rclass2/lectures"`
    - __relative__ filepath: filepath relative to the current directory
        - example [starting from working directory `rclass2`]:
            - `cd lectures`
            - `cd lectures/github`
    - by default, `cd` command assumes you are using a __relative__ filepath
- `../` or `..` -- move up one directory
    - (assume working directory is `"/c/Users/ozanj/documents/rclass2/lectures"`):
    - `cd ..` -- move up one directory to `rclass2`
    - `cd ../problem_sets` -- move up one directory to `rclass2` and then change to `problem_sets` directory
- `./` or `.` -- current directory
    - (assume working directory is `"/c/Users/ozanj/documents/rclass2/lectures"`):
    - `cd .` -- doesn't change current working directory
    - `cd ./` -- doesn't change current working directory
    - `cd ./ggplot` -- changes to directory `lectures/ggplot`
        - same as `cd ggplot`
- `cd` [by itself] or `cd ~` changes to your "home directory"

__Examples using `cd` command__

- can run these commands in .Rmd code chunk or paste them to Terminal/Git Bash command line
- note: when running from .Rmd code chunk the working directory is `rclass2/lectures/github`

Move up one directory level and then show file path and list contents of directory
```{bash}
pwd
cd ../
pwd
ls
```

Move up two directory levels and then show file path and list contents of directory
```{bash}
pwd
cd ../../
pwd
ls
```
Move up two directory levels and then show file path and list contents of directory, including files that begin with `.`
```{bash}
pwd
cd ../../
pwd
ls -a
```

Move up one directory, then change to `ggplot` directory
```{bash}
pwd

cd ../
pwd

cd ggplot
pwd

ls
```

### Make/delete/move folders a

__`mkdir` command makes a directory__

- syntax
    - `mkdir [option(s)] directory_name(s)`
- common option
    - `-p` -- no error if existing, make parent directories as needed

Example

- Make new directory
```{bash, eval = FALSE}
cd ../../../ 
pwd
mkdir mkdir_test
``` 

- move to new directory and create sub-folders
```{bash, eval = FALSE}
cd ../../../
  
cd mkdir_test

mkdir folder_a folder_b folder_c
ls
```

__`rm` command removes a file or folder__

- syntax
    - `rm [option(s)] [file/folder name(s)]`
- common options
    - `-f` -- force remove
        - `rm -f some_file.txt`
    - `-r` -- delete directory (default is deleting a file)
        - `rm -r some_directory`
    - `-rf` -- force remove directory
        - `rm -rf some_directory`

Example

- remove directory named `folder_a`
```{bash, eval = FALSE}
cd ../../../
  
cd mkdir_test

rm -rf folder_a
ls
```

ADD THESE COMMANDS ON 3/25?

cp file1 file2 – copy file1 to file2
cp -r dir1 dir2 – copy dir1 to dir2; create dir2 if it
doesn't exist
mv file1 file2 – rename or move file1 to file2
if file2 is an existing directory, moves file1 into
directory file2

# Basic Git tasks, individual developer

## git commands

### clone an existing repository

give overview of different basic things we will do each day (e.g., create new repository from our computer and then push to github, clone repository on github; and then show how to do it)

CLONE AN EXISTING GIT REPOSITORY
SHOW CODE HERE, BUT BETTER TO RUN IN COMMAND LINE
```{bash, eval = FALSE}
# change directories to home directory
cd ~ 

# change to "documents" [if necessary]
cd documents

# show filepath of current working directory
pwd 

#list files in current working directory
#ls

#clone git repository that is on github.com
#git clone https://github.com/Rucla-ed/student_jaquette.git #http authentication
git clone git@github.com:Rucla-ed/student_jaquette.git # SSH authentication

cd student_jaquette
ls
```


Create new git repository on your local machine and connect it to github

SHOW CODE HERE, BUT BETTER TO RUN IN COMMAND LINE
```{bash, eval = FALSE}
# change directories to home directory
cd ~ 

# change to "documents" [if necessary]
cd documents

# make new directory that will be our git repository
mkdir gitr_practice

cd gitr_practice

ls -a

# turn the current, empty directory into a fresh Git repository.
git init

#create a new README file with some sample text
echo "Hello. I thought we would be learning R this quarter" >> README.txt

#show contents of file
cat README.txt

git status

# add README.txt to files that will be "tracked" by git
git add README.txt

# check status
git status

# commit changes to local repository
git commit -m "First commit"
```

# Git tasks, collaborative projects

## Pull requests

# Appendix

## Installation

## Authentication

## .gitignore

## Running git Bash from R Markdown

